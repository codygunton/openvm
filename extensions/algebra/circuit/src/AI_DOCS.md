# Algebra Circuit Extension - AI Documentation

## Overview

The algebra circuit extension provides modular arithmetic and quadratic field extension (Fp2) operations for OpenVM. This extension enables efficient cryptographic operations over prime fields and their quadratic extensions, supporting multiple moduli simultaneously.

## Core Components

### 1. Modular Arithmetic Extension (`modular_extension.rs`)
- **Purpose**: Implements modular arithmetic operations (add, sub, mul, div, is_equal) over configurable prime fields
- **Key Features**:
  - Supports multiple moduli simultaneously via runtime configuration
  - Automatically selects chip variant based on modulus size (32 or 48 bytes)
  - Includes phantom sub-executors for square root hints and non-quadratic residue computation
  - Generates initialization code for guest programs

### 2. Fp2 Extension (`fp2_extension.rs`)
- **Purpose**: Implements arithmetic over quadratic field extensions Fp2 = Fp[u]/(1 + u²)
- **Key Features**:
  - Built on top of modular arithmetic extension
  - Supports add, sub, mul, div operations for Fp2 elements
  - Requires prime p ≡ 3 (mod 4) so -1 is non-quadratic residue
  - Named moduli support for better guest integration

### 3. Configuration Types (`config.rs`)
- **Rv32ModularConfig**: Configuration with only modular arithmetic
- **Rv32ModularWithFp2Config**: Configuration with both modular and Fp2 arithmetic
- Both generate initialization files for guest programs automatically

## Architecture Details

### Chip Hierarchy
```
ModularExtensionExecutor<F>
├── ModularAddSubRv32_32/48
├── ModularMulDivRv32_32/48
└── ModularIsEqualRv32_32/48

Fp2ExtensionExecutor<F>
├── Fp2AddSubRv32_32/48
└── Fp2MulDivRv32_32/48
```

### Memory Layout
- Modular elements: Stored as little-endian byte arrays (32 or 48 bytes)
- Fp2 elements: Two consecutive modular elements (c0, c1)
- Pointer-based access via heap adapter chips

### Opcode Organization
- Each modulus gets its own opcode range
- Base offset = `CLASS_OFFSET + modulus_index * OPCODE_COUNT`
- Operations: ADD, SUB, MUL, DIV, IS_EQ, SETUP variants

## Key Algorithms

### Square Root Computation
1. For p ≡ 3 (mod 4): x^((p+1)/4) 
2. Otherwise: Tonelli-Shanks algorithm
3. Phantom hints provide either sqrt(x) or sqrt(x·non_qr)

### Non-Quadratic Residue Selection
- p ≡ 3 (mod 4): Use -1
- p ≡ 5 (mod 8): Use 2
- Otherwise: Random search with deterministic seed

### Fp2 Arithmetic
- Addition/Subtraction: Component-wise
- Multiplication: (a + bi)(c + di) = (ac - bd) + (ad + bc)i
- Division: Multiply by conjugate and divide by norm
- Uses constraint system to verify division results

## Integration Points

### Guest Code Generation
```rust
// Generated by generate_moduli_init()
openvm_algebra_guest::moduli_macros::moduli_init! { "modulus1", "modulus2" }

// Generated by generate_complex_init()
openvm_algebra_guest::complex_macros::complex_init! { 
    ComplexField1 { mod_idx = 0 },
    ComplexField2 { mod_idx = 1 }
}
```

### Builder Integration
```rust
let modular_ext = ModularExtension::new(vec![modulus1, modulus2]);
let fp2_ext = Fp2Extension::new(vec![
    ("Fq2".to_string(), modulus1),
    ("Fq12".to_string(), modulus2),
]);
```

## Performance Considerations

1. **Chip Selection**: Automatic selection between 32-byte and 48-byte variants
2. **Bitwise Lookup**: Shared lookup table for efficient range checking
3. **Offline Memory**: Used for instruction fetching and setup
4. **Auto-save**: Fp2 division automatically saves intermediate values

## Security Features

1. **Range Checking**: All limbs verified to be within valid bounds
2. **Modulus Validation**: Ensures operations stay within field
3. **Deterministic Non-QR**: Uses fixed seed for reproducibility
4. **Constraint Verification**: Division results verified via multiplication

## Common Patterns

### Adding New Field Operations
1. Define operation in `openvm_algebra_transpiler`
2. Create chip implementation in appropriate module
3. Register opcodes in extension's `build()` method
4. Update guest macros if needed

### Supporting Larger Moduli
1. Add new chip variants (e.g., 64-byte)
2. Update modulus size detection logic
3. Ensure adapter chips support new size
4. Test with target cryptographic parameters

## Debugging Tips

1. **Modulus Index Errors**: Check supported_moduli ordering matches guest init
2. **Range Check Failures**: Verify limb count matches modulus size
3. **Constraint Violations**: Check auto-save triggers in Fp2 operations
4. **Phantom Failures**: Ensure modulus index is within bounds

## Dependencies

- `openvm-mod-circuit-builder`: Expression builder for modular arithmetic
- `openvm-circuit-primitives`: Bitwise operations and lookup tables
- `openvm-rv32-adapters`: Memory access adapters for RISC-V
- `num-bigint`: Arbitrary precision arithmetic
- `openvm-algebra-transpiler`: Opcode definitions